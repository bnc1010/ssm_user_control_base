





用户表：

| u_id（primary key） | userName | password | others   |
| ------------------- | -------- | -------- | -------- |
| 用户id              | 用户名   | 密码     | 其它信息 |



角色表：

| r_id（primary key） | r_name | r_type                            |
| ------------------- | ------ | --------------------------------- |
| 角色id              | 角色名 | 角色类型（管理员，普通/特殊用户） |



权限表：

| p_id（primary key） | p_url             | p_name | p_code |
| ------------------- | ----------------- | ------ | ------ |
| 权限id              | url（正则表达式） | 权限名 | 权限码 |



用户-角色表：

| r_id（foreign key） | u_id（foreign key） |
| ------------------- | ------------------- |
| 角色id              | 用户id              |



角色-权限表：

| r_id（foreign key） | p_id（foreign key） |
| ------------------- | ------------------- |
| 角色id              | 权限id              |



个人感觉前后端分离项目中，后端提供可访问的api接口，api可访问性的权限是很扁平的

一个权限可以表示为一个正则表达式，如/system/.*可以匹配所有/system/...下的路径，如果这个是所有系统管理的api，一个子权限如日志查看(url:/system/log/)，另外有一个角色有查看日志的权限，无其它权限，那么就可以给这个角色一个正则表达式为/system/log/的权限，严格匹配日志查看的api地址。

在逻辑上权限是有父子继承关系，如上面的/system/log/是/system/.*的子权限，但是可以忽略它，把所有权限同等对待。角色也是如此。



约定权限都是平等关系，无继承等复杂关系，角色同理。

用户可以有多个角色，其权限为所拥有的角色的权限的并，正是因为权限平等，可以简单地用并来处理。